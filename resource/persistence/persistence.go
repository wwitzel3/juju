// Copyright 2015 Canonical Ltd.
// Licensed under the AGPLv3, see LICENCE file for details.

package persistence

import (
	"github.com/juju/errors"
	"github.com/juju/loggo"
	jujutxn "github.com/juju/txn"
	"gopkg.in/mgo.v2/txn"

	"github.com/juju/juju/resource"
)

var logger = loggo.GetLogger("juju.resource.persistence")

// PersistenceBase exposes the core persistence functionality needed
// for resources.
type PersistenceBase interface {
	// All populates docs with the list of the documents corresponding
	// to the provided query.
	All(collName string, query, docs interface{}) error

	// Run runs the transaction generated by the provided factory
	// function. It may be retried several times.
	Run(transactions jujutxn.TransactionSource) error
}

// Persistence provides the persistence functionality for the
// Juju environment as a whole.
type Persistence struct {
	base PersistenceBase
}

// NewPersistence wraps the base in a new Persistence.
func NewPersistence(base PersistenceBase) *Persistence {
	return &Persistence{
		base: base,
	}
}

// ListResources returns the resource data for the given service ID.
func (p Persistence) ListResources(serviceID string) ([]resource.Resource, error) {
	logger.Tracef("listing all resources for service %q", serviceID)

	// TODO(ericsnow) Ensure that the service is still there?

	docs, err := p.resources(serviceID)
	if err != nil {
		return nil, errors.Trace(err)
	}

	var results []resource.Resource
	for _, doc := range docs {
		res, err := doc2resource(doc)
		if err != nil {
			return nil, errors.Trace(err)
		}
		results = append(results, res)
	}
	return results, nil
}

// SetStagedResource adds the resource in a separate staging area
// if the resource isn't already staged. If it is then
// errors.AlreadyExists is returned.
func (p Persistence) SetStagedResource(id, serviceID string, res resource.Resource) error {
	// TODO(ericsnow) Ensure that the service is still there?

	if err := res.Validate(); err != nil {
		return errors.Annotate(err, "bad resource")
	}

	buildTxn := func(attempt int) ([]txn.Op, error) {
		var ops []txn.Op
		switch attempt {
		case 0:
			ops = p.newStagedResourceOps(id, serviceID, res)
		case 1:
			ops = p.newEnsureStagedSameOps(id, serviceID, res)
		default:
			return nil, errors.NewAlreadyExists(nil, "already staged")
		}

		return ops, nil
	}
	if err := p.base.Run(buildTxn); err != nil {
		return errors.Trace(err)
	}
	return nil
}

// UnstageResource ensures that the resource is removed
// from the staging area. If it isn't in the staging area
// then this is a noop.
func (p Persistence) UnstageResource(id, serviceID string) error {
	// TODO(ericsnow) Ensure that the service is still there?

	buildTxn := func(attempt int) ([]txn.Op, error) {
		if attempt > 0 {
			// The op has no assert so we should not get here.
			return nil, errors.New("unstaging the resource failed")
		}

		ops := p.newRemoveStagedOps(id, serviceID)
		return ops, nil
	}
	if err := p.base.Run(buildTxn); err != nil {
		return errors.Trace(err)
	}
	return nil
}

// SetResource stores the resource info. This is an "upsert". If the
// resource is already staged then it is unstaged. The caller is
// responsible for getting the staging right.
func (p Persistence) SetResource(id, serviceID string, res resource.Resource) error {
	// TODO(ericsnow) Ensure that the service is still there?

	if err := res.Validate(); err != nil {
		return errors.Annotate(err, "bad resource")
	}

	buildTxn := func(attempt int) ([]txn.Op, error) {
		// This is an "upsert".
		var ops []txn.Op
		switch attempt {
		case 0:
			ops = p.newInsertResourceOps(id, serviceID, res)
		case 1:
			ops = p.newUpdateResourceOps(id, serviceID, res)
		default:
			// Either insert or update will work so we should not get here.
			return nil, errors.New("setting the resource failed")
		}
		// No matter what, we always remove any staging.
		ops = append(ops, p.newRemoveStagedOps(id, serviceID)...)
		return ops, nil
	}
	if err := p.base.Run(buildTxn); err != nil {
		return errors.Trace(err)
	}
	return nil
}
